<processor-rules>
	<!--types - splitregex,  matchandtranslate-->
	<globalrules>
		<rule type="splitRegex">
			<name>deliveryDateSplit</name>
			<input>Delivery Date</input>
			<split>
				<regex>(.*)</regex>
				<group number='1'>
					<node name='deliveryDateRaw'></node>
				</group>
			</split>
			<split>
				<regex>([0-9]+\/[0-9]+\/[0-9]+)</regex>
				<group number='1'>
					<node name='Delivery Date'></node>
				</group>
			</split>
		</rule>

		<rule type="coerceDate">
			<name>coerceIssueDate</name>
			<input>PO Date</input>
		</rule>
		<rule type="coerceDate">
			<name>coerceDeliveryDate</name>
			<input>Delivery Date</input>
		</rule>
		<rule type="coerceDate">
			<name>coerceGalvanisedDate</name>
			<input>Galvanised</input>
		</rule>

		<rule type="copyToItems">
			<name>copyPONum</name>
			<input>PO Number</input>
			<newnodename>PO Number</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copyNettAmount</name>
			<input>Nett Amount</input>
			<newnodename>Nett Amount</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copyFilename</name>
			<input>Filename</input>
			<newnodename>Filename</newnodename>
		</rule>

		<rule type="copyToItems">
			<name>copyPODate</name>
			<input>PO Date</input>
			<newnodename>PO Date</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copyPODate</name>
			<input>PO Date</input>
			<newnodename>PO Date</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copyFB</name>
			<input>F/B (scraped)</input>
			<newnodename>F/B (scraped)</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copySite</name>
			<input>Project Site</input>
			<newnodename>Project Site</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copyNoteRaw</name>
			<input>Note Raw</input>
			<newnodename>Note Raw</newnodename>
		</rule>

		<rule type="copyToItems">
			<name>copyDetailRaw</name>
			<input>Detail Raw</input>
			<newnodename>Detail Raw</newnodename>
		</rule>

		<rule type="copyToItems">
			<name>copyDeliveryDate</name>
			<input>Delivery Date</input>
			<newnodename>PO Delivery Date</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copyDeliveryDateRaw</name>
			<input>deliveryDateRaw</input>
			<newnodename>Delivery Date Raw</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copyTakeFrom</name>
			<input>Take From</input>
			<newnodename>Take From</newnodename>
		</rule>
		<rule type="copyToItems">
			<name>copyCheckString</name>
			<input>checkString</input>
			<newnodename>checkString</newnodename>
		</rule>
	</globalrules>


	<itemrules>

		<rule type="alias">
			<name>renameFields</name>
			<alias name='dia(mm)'>Size</alias>
			<alias name='f.lgth'>Casing Length (Special)</alias>
			<alias name='rpm'>Motor Speed</alias>
			<alias name='motor(kw)'>Motor Size</alias>
			<alias name='flc(amp)'>Motor Amp</alias>
			<alias name='cl'>motorClass</alias>
			<alias name='wt(kg)'>Fan Weight in kg</alias>
			<alias name='dbA@3m'>Noise Level</alias>
			<alias name='f.up'>Price per Unit</alias>
			<alias name='m.brand'>motorBrand</alias>
			<alias name='Frame'>Motor Frame (Scraped)</alias>
			<alias name='fr'>Motor Frame (Scraped)</alias>
		</rule>
		<!--these are for silencers only-->
		<rule type="copyNode">
			<name>copySilencerPrice</name>
			<condition type='nodeDoesNotExist'>
				<node name='Price per Unit'></node>
			</condition>
			<input>s.up</input>
			<newnodename>Price per Unit</newnodename>
		</rule>
		<rule type="copyNode">
			<name>copySilencerQty</name>
			<condition type='nodeDoesNotExist'>
				<node name='qty'></node>
			</condition>
			<input>s.qty</input>
			<newnodename>qty</newnodename>
		</rule>
		<rule type="copyNode">
			<name>copySilencermodel</name>
			<condition type='nodeDoesNotExist'>
				<node name='model'></node>
			</condition>
			<input>s.model</input>
			<newnodename>model</newnodename>
		</rule>
		<!--end silencers only-->

		<rule type="copyNode">
			<name>copyModelStringToImpeller</name>
			<input>model</input>
			<newnodename>Impeller</newnodename>
		</rule>
		<rule type="copyNode">
			<name>copyTargetedToDelivery</name>
			<!--<condition type='match'>-->
				<!--<regex>[a-zA-Z]+</regex> [>if there are letters in the date field<]-->
				<!--<node name='PO Delivery Date'></node>-->
			<!--</condition>-->
			<input>TargetedDate</input>
			<newnodename>PO Delivery Date</newnodename>
		</rule>
		<rule type="coerceDate">
			<name>itemcoerceDeliveryDate</name>
			<input>PO Delivery Date</input>
		</rule>
		<rule type="splitRegex">
			<name>supplySplit</name>
			<input>supply</input>
			<split>
				<regex>^([0-9]+)\/.*</regex>
				<group number='1'>
					<node name='motorVoltage'></node>
				</group>
			</split>
		</rule>
		<rule type="splitRegex">
			<name>MotorFrameSplit</name>
			<input>Motor Frame (Scraped)</input>
			<split>
				<regex>(?i)(63|71|80M|80|90L|90S|90|100L|100|112M|112|132M|132S|132|160M|160L|160|180M|180L|180|200L|200M|225M|225S|225|250M|250|280M|280S|280|315L|315M|315S|315|355M|355)</regex>
				<group number='1'>
					<node name='Motor Frame (Scraped)'></node>
				</group>
			</split>
		</rule>

		<rule type="splitRegex"> <!--Main Model String Split-->
			<name>modelSplit</name>
			<input>model</input>
			<split>
				<regex>^(AXV|AXG|BIF AXV|AXV BIF|BXV|BIF BXV|BXV BIF|MFLG|AXV PM)\s*[0-9]</regex>
				<group number='1'>
					<node name='modelstringItem'></node>
				</group>
			</split>
			<split>
				<regex>(MFLG)\s*([0-9]+)</regex>
				<group number='1'>
					<node name='modelstringItem'></node>
				</group>
				<group number='2'>
					<node name='Size'></node>
				</group>
			</split>
			<split>
				<regex>(?i)shaft\s+adaptor</regex>
				<group number='1'>
					<node name='modelstringItem'></node>
				</group>
			</split>
			<split>
				<regex>^(AXG)\s*([0-9]+)".*</regex>  <!--specs in inches-->
				<group number='1'>
					<node name='modelstringItem'></node>
				</group>
				<group number='2'>
					<node name='t_SizeInInches'></node>
				</group>
			</split>
			<split>
				<regex>^(MTF)\s*([0-9]+)</regex>
				<group number='1'>
					<node name='modelstringItem'></node>
				</group>
				<group number='2'>
					<node name='Size'></node>
				</group>
			</split>
			<split>
				<regex>(?i).*(exd|exn).*</regex>
				<group number='1'>
					<node name='modelstringExtra'></node>
				</group>
			</split>
		</rule>
		<rule type="matchAndTranslate">
			<name>translatefromfuckinginches</name>
			<input>t_SizeInInches</input>
			<translate>
				<match input='t_SizeInInches'>21</match>
				<node name='Size'>535</node>
			</translate>
		</rule>
		<rule type="matchAndTranslate">
			<name>removeALU</name>
			<input>Motor Frame (Scraped)</input>
			<translate>
				<match input='Motor Frame (Scraped)'>ALU</match>
				<node name='Motor Frame (Scraped)'></node>
			</translate>
		</rule>
		<rule type="splitRegex">
			<name>motorsizeMultiples</name>
			<input>Motor Size</input>
			<split>
				<regex>^([0-9.]+)\s*x\s*[0-9]+</regex>
				<group number='1'> 
					<node name='Motor Size'></node>
				</group>
			</split>
		</rule>
		<rule type="splitRegex">
			<name>modelSplitSilencers</name>
			<input>model</input>
			<split>
				<regex>^(SPA)(-[0-9]D?)-([0-9]+)</regex>
				<group number='1'>
					<node name='modelstringItem'></node>
				</group>
				<group number='2'>
					<node name='modelstringSilencerSize'></node>
				</group>

				<!-- 'silencerSpecialSIze' goes to {size} field eventually but may need processing for silencers only-->
				<group number='3'>
					<node name='modelstringSilencerSpecialSize'></node> 				
				</group>
			</split>
			<split>
				<regex>^(RSD)([0-9]+)\/([0-9])?</regex>
				<group number='1'>
					<node name='modelstringItem'></node>
				</group>
				<group number='2'>
					<node name='Size'></node>
				</group>
				<group number='3'>
					<node name='modelstringSilencerSizeSlash'></node>
				</group>
			</split>
		</rule>

		<rule type="splitRegex">
			<name>motorClassExtractLetter</name>
			<input>motorClass</input>
			<split>
				<regex>([A-Z]).*</regex>
				<group number='1'>
					<node name='motorClass'></node>
				</group>
			</split>
		</rule>

		<!--extract numbers from casing length to remove 'x2' and other bullshit-->
		<rule type="splitRegex">
			<name>casinglengthspecialExtractNumber</name>
			<input>Casing Length (Special)</input>
			<split>
				<regex>([0-9.]+)</regex>
				<group number='1'>
					<node name='Casing Length (Special)'></node>
				</group>
			</split>
		</rule>

		<rule type="splitRegex">
			<name>motorClassExtractLetter</name>
			<input>motorClass</input>
			<split>
				<regex>([A-Z]).*</regex>
				<group number='1'>
					<node name='motorClass'></node>
				</group>
			</split>
		</rule>
		<rule type="splitRegex">
			<name>motorClassExtractLetter</name>
			<input>motorClass</input>
			<split>
				<regex>([A-Z]).*</regex>
				<group number='1'>
					<node name='motorClass'></node>
				</group>
			</split>
		</rule>
		<rule type="splitRegex">
			<name>motorClassExtractLetter</name>
			<input>motorClass</input>
			<split>
				<regex>([A-Z]).*</regex>
				<group number='1'>
					<node name='motorClass'></node>
				</group>
			</split>
		</rule>

		<rule type="matchAndTranslate">
			<name>addVtoVoltage</name>
			<input>motorVoltage</input>
			<translate>
				<match input='motorVoltage'>.+</match>
				<node name='motorVoltage'>{motorVoltage}V</node>
			</translate>
		</rule>
		
		<rule type="matchAndTranslate">
			<name>addClasstoClass</name>
			<input>motorClass</input>
			<translate>
				<match input='motorClass'>[A-Z]</match>
				<node name='motorClass'>Class {motorClass}</node>
			</translate>
		</rule>

		<rule type="matchAndTranslate">
			<name>translatemotorBrand</name>
			<input>motorBrand</input>
			<translate>
				<match input='motorBrand'>(ATT)</match>
				<node name='motorBrand'>Att</node>
			</translate>
		</rule>
		
		<rule type="matchAndTranslate">
			<name>cwCornerBracket</name>
			<input>Note Raw</input>
			<translate>
				<match input='Note Raw'>(?i)corner bracket.*</match>
				<node name='F/B (scraped)'>F/B</node>
			</translate>
			<translate>
				<match input='Note Raw'>(?i).*corner bracket.*\(\s*no need\)</match>
				<node name='F/B (scraped)'>不用F/B</node>
			</translate>
			<translate>
				<match input='Note Raw'>(?i).*no\s*need.*corner\s*bracket</match>
				<node name='F/B (scraped)'>不用F/B</node>
			</translate>
		</rule>

		<!--strip '-' from output strings for f.lgth-->
		<rule type="matchAndTranslate">
			<name>casinglength</name>
			<input>Casing Length (Special)</input>
			<translate>
				<match input='Casing Length (Special)'>^\s*-\s*$</match>
				<node name='Casing Length (Special)'></node>
			</translate>
		</rule>


		<rule type="matchAndTranslate"> <!--massaging model names-->
			<name>translatemodelstringItem</name>
			<!--<nextrule>foo</nextrule>-->
			<input>modelstringItem</input>
			<input>modelstringExtra</input>
			<translate>
				<match input='modelstringItem'>[A|B]XV BIF</match>
				<node name="modelstringItem">Bif</node>
			</translate>
			<translate>
				<match input='modelstringItem'>BIF [A|B]XV</match>
				<node name="modelstringItem">Bif</node>
			</translate>
			<translate>
				<match input='modelstringItem'>AXV PM</match>
				<node name="modelstringItem">DQ-Ax</node>
			</translate>
			<translate>
				<match input='modelstringItem'>AXV</match>
				<node name="modelstringItem">Ax</node>
			</translate>
			<translate>
				<match input='modelstringItem'>AXG</match>
				<node name="modelstringItem">Ax</node>
			</translate>
			<translate> <!--this needs to go before the more general case below-->
				<match input='modelstringItem'>Ax</match>
				<match input='modelstringExtra'>(?i)exn</match>
				<node name="modelstringItem">Ax-Ex</node>
			</translate>
			<translate> <!--this needs to go before the more general case below-->
				<match input='modelstringItem'>BXV</match>
				<match input='modelstringExtra'>exd</match>
				<node name="modelstringItem">Ax-Ex</node>
			</translate>
			<translate>
				<match input='modelstringItem'>BXV</match>
				<node name="modelstringItem">Ax</node>
			</translate>
			<translate>
				<match input='modelstringItem'>MFLG</match>
				<node name="modelstringItem">MFlanges</node>
			</translate>
			<translate>
				<match input='modelstringItem'>MTF</match>
				<node name="modelstringItem">MFeet</node>
			</translate>
			<!--silencers-->
			<translate>
				<match input='modelstringItem'>SPA</match>
				<node name="modelstringItem">RSM</node>
			</translate>
			<translate>
				<match input='modelstringItem'>RSD</match>
				<node name="modelstringItem">RS</node>
			</translate>
		</rule>
		<rule type="matchAndTranslate"> <!-- adding taper to bif -->
			<name>translateBifTP</name>
			<input>modelstringItem</input>
			<input>model</input>
			<translate>
				<match input='modelstringItem'>Bif</match>
				<match input='model'>(?i).*taper.*</match>
				<node name='modelstringItem'>Bif T/p</node>
			</translate>
		</rule>
		<rule type="matchAndTranslate"> <!--translating shaft adaptor from Ref field cos the client can't be fucking consistent ever-->
			<name>translateShaftAdaptorfromRef</name>
			<input>ref.</input>
			<translate>
				<match input='ref.'>(?i)shaft\s+adaptor</match>
				<node name='modelstringItem'>Shaft Adaptor</node>
			</translate>
		</rule>
		<rule type="matchAndTranslate"> <!--changing silencer size /3 etc-->
			<name>translatemodelstringSilencerSize</name>
			<input>modelstringSilencerSizeSlash</input>
			<translate>
				<match input='modelstringSilencerSizeSlash'>([0-9])</match>
				<node name="modelstringSilencerSize">-{modelstringSilencerSizeSlash}00mmL Collar</node>
			</translate>
		</rule>
		<rule type="matchAndTranslate"> <!--rsm 310 and 350 should be 315 and 355 for some fucking insane reason-->
			<name>translatersm310350</name>
			<input>Size</input>
			<input>modelstringSilencerSpecialSize</input>
			<translate>
				<match input='modelstringItem'>RSM</match>
				<match input='modelstringSilencerSpecialSize'>31</match>
				<node name='Size'>315</node>
			</translate>
			<translate>
				<match input='modelstringItem'>RSM</match>
				<match input='modelstringSilencerSpecialSize'>35</match>
				<node name='Size'>355</node>
			</translate>
		</rule>
		<rule type="matchAndTranslate">
			<name>1350rpmto1380</name>
			<input>Motor Speed</input>
			<translate>
				<match input='Motor Speed'>1350</match>
				<node name='Motor Speed'>1380</node>
			</translate>
		</rule>
		<rule type='mathx10RS'>
			<name>modelstringSilencerSpecialSize</name>
			<condition type='nodeDoesNotExist'>
				<node name='Size'></node>
			</condition>
			<input>modelstringSilencerSpecialSize</input>
			<node name='Size'></node>
		</rule>


	</itemrules>
	<checkrules>
		<rule type='uploadnodes'>
			<name>upload group 1</name>
			<node name='s/n' type='string'>Item No.</node>
			<node name='Project Site'></node>
			<node name='PO Date' type='datetime'></node>
			<node name='PO Delivery Date' type='datetime'></node>
			<node name='Note Raw'></node>
			<node name='Size' type='string'></node>
			<node name='qty' type='int'>Qty</node>
			<node name='model' type='string'>Item Raw</node>
			<node name='detailSplit'>Detail Raw</node>
			<node name='modelstringItem'>Item</node>
			<node name='modelstringSilencerSize'>Silencer Size</node>
			<node name='Impeller'></node>
			<node name='Fan Weight in kg'></node>
			<node name='Noise Level' type='string'></node>
			<node name='Casing Length (Special)' type='string'></node>
			<node name='T/BOX'>T-box Position</node>
			<node name='Motor Size' type='string' extra='stripspaces'></node>
			<node name='motorClass'>Motor Class</node>
			<node name='motorBrand'>Motor Brand</node>
			<node name='Motor Speed' type='string' extra='stripspaces'></node>
			<node name='motorVoltage'>Motor Voltage</node>
			<node name='modelstringSpacerThickness'>Thickness (From PO)</node>
			<node name='F/B (scraped)'></node>
			<node name='greaseNippleRemark'>Grease Nipple Remark</node>
			<node name='Reason' type='list'>Reason for Urgency</node>
			<node name='Motor Frame (Scraped)'></node>
			<node name='Nett Amount' type='float'></node>
			<node name='Price per Unit' type='float'></node>
			<node name='Take From'></node>
			<node name='PO Number' type='string'></node>
			<node name='Galvanised' type='datetime'>Galvanised/Fabrication Date (Requested)</node>
			<node name='Filename'></node>
			<node name='checkString'></node>
		</rule>
	</checkrules>
</processor-rules>
